# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from ibeo_msgs/ErrorWarning.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import genpy
import ibeo_msgs.msg
import std_msgs.msg

class ErrorWarning(genpy.Message):
  _md5sum = "c325629d3f8237469cf0318dbfa5ea2c"
  _type = "ibeo_msgs/ErrorWarning"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """Header header

IbeoDataHeader ibeo_header
bool err_internal_error
bool err_motor_1_fault
bool err_buffer_error_xmt_incomplete
bool err_buffer_error_overflow
bool err_apd_over_temperature
bool err_apd_under_temperature
bool err_apd_temperature_sensor_defect
bool err_motor_2_fault
bool err_motor_3_fault
bool err_motor_4_fault
bool err_motor_5_fault
bool err_int_no_scan_data
bool err_int_communication_error
bool err_int_incorrect_scan_data
bool err_config_fpga_not_configurable
bool err_config_incorrect_config_data
bool err_config_contains_incorrect_params
bool err_timeout_data_processing
bool err_timeout_env_model_computation_reset
bool wrn_int_communication_error
bool wrn_low_temperature
bool wrn_high_temperature
bool wrn_int_motor_1
bool wrn_sync_error
bool wrn_laser_1_start_pulse_missing
bool wrn_laser_2_start_pulse_missing
bool wrn_can_interface_blocked
bool wrn_eth_interface_blocked
bool wrn_incorrect_can_data_rcvd
bool wrn_int_incorrect_scan_data
bool wrn_eth_unkwn_incomplete_data
bool wrn_incorrect_or_forbidden_cmd_rcvd
bool wrn_memory_access_failure
bool wrn_int_overflow
bool wrn_ego_motion_data_missing
bool wrn_incorrect_mounting_params
bool wrn_no_obj_comp_due_to_scan_freq

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: ibeo_msgs/IbeoDataHeader
uint32 previous_message_size
uint32 message_size
uint8 device_id
uint16 data_type_id
time stamp
"""
  __slots__ = ['header','ibeo_header','err_internal_error','err_motor_1_fault','err_buffer_error_xmt_incomplete','err_buffer_error_overflow','err_apd_over_temperature','err_apd_under_temperature','err_apd_temperature_sensor_defect','err_motor_2_fault','err_motor_3_fault','err_motor_4_fault','err_motor_5_fault','err_int_no_scan_data','err_int_communication_error','err_int_incorrect_scan_data','err_config_fpga_not_configurable','err_config_incorrect_config_data','err_config_contains_incorrect_params','err_timeout_data_processing','err_timeout_env_model_computation_reset','wrn_int_communication_error','wrn_low_temperature','wrn_high_temperature','wrn_int_motor_1','wrn_sync_error','wrn_laser_1_start_pulse_missing','wrn_laser_2_start_pulse_missing','wrn_can_interface_blocked','wrn_eth_interface_blocked','wrn_incorrect_can_data_rcvd','wrn_int_incorrect_scan_data','wrn_eth_unkwn_incomplete_data','wrn_incorrect_or_forbidden_cmd_rcvd','wrn_memory_access_failure','wrn_int_overflow','wrn_ego_motion_data_missing','wrn_incorrect_mounting_params','wrn_no_obj_comp_due_to_scan_freq']
  _slot_types = ['std_msgs/Header','ibeo_msgs/IbeoDataHeader','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,ibeo_header,err_internal_error,err_motor_1_fault,err_buffer_error_xmt_incomplete,err_buffer_error_overflow,err_apd_over_temperature,err_apd_under_temperature,err_apd_temperature_sensor_defect,err_motor_2_fault,err_motor_3_fault,err_motor_4_fault,err_motor_5_fault,err_int_no_scan_data,err_int_communication_error,err_int_incorrect_scan_data,err_config_fpga_not_configurable,err_config_incorrect_config_data,err_config_contains_incorrect_params,err_timeout_data_processing,err_timeout_env_model_computation_reset,wrn_int_communication_error,wrn_low_temperature,wrn_high_temperature,wrn_int_motor_1,wrn_sync_error,wrn_laser_1_start_pulse_missing,wrn_laser_2_start_pulse_missing,wrn_can_interface_blocked,wrn_eth_interface_blocked,wrn_incorrect_can_data_rcvd,wrn_int_incorrect_scan_data,wrn_eth_unkwn_incomplete_data,wrn_incorrect_or_forbidden_cmd_rcvd,wrn_memory_access_failure,wrn_int_overflow,wrn_ego_motion_data_missing,wrn_incorrect_mounting_params,wrn_no_obj_comp_due_to_scan_freq

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(ErrorWarning, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.ibeo_header is None:
        self.ibeo_header = ibeo_msgs.msg.IbeoDataHeader()
      if self.err_internal_error is None:
        self.err_internal_error = False
      if self.err_motor_1_fault is None:
        self.err_motor_1_fault = False
      if self.err_buffer_error_xmt_incomplete is None:
        self.err_buffer_error_xmt_incomplete = False
      if self.err_buffer_error_overflow is None:
        self.err_buffer_error_overflow = False
      if self.err_apd_over_temperature is None:
        self.err_apd_over_temperature = False
      if self.err_apd_under_temperature is None:
        self.err_apd_under_temperature = False
      if self.err_apd_temperature_sensor_defect is None:
        self.err_apd_temperature_sensor_defect = False
      if self.err_motor_2_fault is None:
        self.err_motor_2_fault = False
      if self.err_motor_3_fault is None:
        self.err_motor_3_fault = False
      if self.err_motor_4_fault is None:
        self.err_motor_4_fault = False
      if self.err_motor_5_fault is None:
        self.err_motor_5_fault = False
      if self.err_int_no_scan_data is None:
        self.err_int_no_scan_data = False
      if self.err_int_communication_error is None:
        self.err_int_communication_error = False
      if self.err_int_incorrect_scan_data is None:
        self.err_int_incorrect_scan_data = False
      if self.err_config_fpga_not_configurable is None:
        self.err_config_fpga_not_configurable = False
      if self.err_config_incorrect_config_data is None:
        self.err_config_incorrect_config_data = False
      if self.err_config_contains_incorrect_params is None:
        self.err_config_contains_incorrect_params = False
      if self.err_timeout_data_processing is None:
        self.err_timeout_data_processing = False
      if self.err_timeout_env_model_computation_reset is None:
        self.err_timeout_env_model_computation_reset = False
      if self.wrn_int_communication_error is None:
        self.wrn_int_communication_error = False
      if self.wrn_low_temperature is None:
        self.wrn_low_temperature = False
      if self.wrn_high_temperature is None:
        self.wrn_high_temperature = False
      if self.wrn_int_motor_1 is None:
        self.wrn_int_motor_1 = False
      if self.wrn_sync_error is None:
        self.wrn_sync_error = False
      if self.wrn_laser_1_start_pulse_missing is None:
        self.wrn_laser_1_start_pulse_missing = False
      if self.wrn_laser_2_start_pulse_missing is None:
        self.wrn_laser_2_start_pulse_missing = False
      if self.wrn_can_interface_blocked is None:
        self.wrn_can_interface_blocked = False
      if self.wrn_eth_interface_blocked is None:
        self.wrn_eth_interface_blocked = False
      if self.wrn_incorrect_can_data_rcvd is None:
        self.wrn_incorrect_can_data_rcvd = False
      if self.wrn_int_incorrect_scan_data is None:
        self.wrn_int_incorrect_scan_data = False
      if self.wrn_eth_unkwn_incomplete_data is None:
        self.wrn_eth_unkwn_incomplete_data = False
      if self.wrn_incorrect_or_forbidden_cmd_rcvd is None:
        self.wrn_incorrect_or_forbidden_cmd_rcvd = False
      if self.wrn_memory_access_failure is None:
        self.wrn_memory_access_failure = False
      if self.wrn_int_overflow is None:
        self.wrn_int_overflow = False
      if self.wrn_ego_motion_data_missing is None:
        self.wrn_ego_motion_data_missing = False
      if self.wrn_incorrect_mounting_params is None:
        self.wrn_incorrect_mounting_params = False
      if self.wrn_no_obj_comp_due_to_scan_freq is None:
        self.wrn_no_obj_comp_due_to_scan_freq = False
    else:
      self.header = std_msgs.msg.Header()
      self.ibeo_header = ibeo_msgs.msg.IbeoDataHeader()
      self.err_internal_error = False
      self.err_motor_1_fault = False
      self.err_buffer_error_xmt_incomplete = False
      self.err_buffer_error_overflow = False
      self.err_apd_over_temperature = False
      self.err_apd_under_temperature = False
      self.err_apd_temperature_sensor_defect = False
      self.err_motor_2_fault = False
      self.err_motor_3_fault = False
      self.err_motor_4_fault = False
      self.err_motor_5_fault = False
      self.err_int_no_scan_data = False
      self.err_int_communication_error = False
      self.err_int_incorrect_scan_data = False
      self.err_config_fpga_not_configurable = False
      self.err_config_incorrect_config_data = False
      self.err_config_contains_incorrect_params = False
      self.err_timeout_data_processing = False
      self.err_timeout_env_model_computation_reset = False
      self.wrn_int_communication_error = False
      self.wrn_low_temperature = False
      self.wrn_high_temperature = False
      self.wrn_int_motor_1 = False
      self.wrn_sync_error = False
      self.wrn_laser_1_start_pulse_missing = False
      self.wrn_laser_2_start_pulse_missing = False
      self.wrn_can_interface_blocked = False
      self.wrn_eth_interface_blocked = False
      self.wrn_incorrect_can_data_rcvd = False
      self.wrn_int_incorrect_scan_data = False
      self.wrn_eth_unkwn_incomplete_data = False
      self.wrn_incorrect_or_forbidden_cmd_rcvd = False
      self.wrn_memory_access_failure = False
      self.wrn_int_overflow = False
      self.wrn_ego_motion_data_missing = False
      self.wrn_incorrect_mounting_params = False
      self.wrn_no_obj_comp_due_to_scan_freq = False

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_2IBH2I37B().pack(_x.ibeo_header.previous_message_size, _x.ibeo_header.message_size, _x.ibeo_header.device_id, _x.ibeo_header.data_type_id, _x.ibeo_header.stamp.secs, _x.ibeo_header.stamp.nsecs, _x.err_internal_error, _x.err_motor_1_fault, _x.err_buffer_error_xmt_incomplete, _x.err_buffer_error_overflow, _x.err_apd_over_temperature, _x.err_apd_under_temperature, _x.err_apd_temperature_sensor_defect, _x.err_motor_2_fault, _x.err_motor_3_fault, _x.err_motor_4_fault, _x.err_motor_5_fault, _x.err_int_no_scan_data, _x.err_int_communication_error, _x.err_int_incorrect_scan_data, _x.err_config_fpga_not_configurable, _x.err_config_incorrect_config_data, _x.err_config_contains_incorrect_params, _x.err_timeout_data_processing, _x.err_timeout_env_model_computation_reset, _x.wrn_int_communication_error, _x.wrn_low_temperature, _x.wrn_high_temperature, _x.wrn_int_motor_1, _x.wrn_sync_error, _x.wrn_laser_1_start_pulse_missing, _x.wrn_laser_2_start_pulse_missing, _x.wrn_can_interface_blocked, _x.wrn_eth_interface_blocked, _x.wrn_incorrect_can_data_rcvd, _x.wrn_int_incorrect_scan_data, _x.wrn_eth_unkwn_incomplete_data, _x.wrn_incorrect_or_forbidden_cmd_rcvd, _x.wrn_memory_access_failure, _x.wrn_int_overflow, _x.wrn_ego_motion_data_missing, _x.wrn_incorrect_mounting_params, _x.wrn_no_obj_comp_due_to_scan_freq))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.ibeo_header is None:
        self.ibeo_header = ibeo_msgs.msg.IbeoDataHeader()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 56
      (_x.ibeo_header.previous_message_size, _x.ibeo_header.message_size, _x.ibeo_header.device_id, _x.ibeo_header.data_type_id, _x.ibeo_header.stamp.secs, _x.ibeo_header.stamp.nsecs, _x.err_internal_error, _x.err_motor_1_fault, _x.err_buffer_error_xmt_incomplete, _x.err_buffer_error_overflow, _x.err_apd_over_temperature, _x.err_apd_under_temperature, _x.err_apd_temperature_sensor_defect, _x.err_motor_2_fault, _x.err_motor_3_fault, _x.err_motor_4_fault, _x.err_motor_5_fault, _x.err_int_no_scan_data, _x.err_int_communication_error, _x.err_int_incorrect_scan_data, _x.err_config_fpga_not_configurable, _x.err_config_incorrect_config_data, _x.err_config_contains_incorrect_params, _x.err_timeout_data_processing, _x.err_timeout_env_model_computation_reset, _x.wrn_int_communication_error, _x.wrn_low_temperature, _x.wrn_high_temperature, _x.wrn_int_motor_1, _x.wrn_sync_error, _x.wrn_laser_1_start_pulse_missing, _x.wrn_laser_2_start_pulse_missing, _x.wrn_can_interface_blocked, _x.wrn_eth_interface_blocked, _x.wrn_incorrect_can_data_rcvd, _x.wrn_int_incorrect_scan_data, _x.wrn_eth_unkwn_incomplete_data, _x.wrn_incorrect_or_forbidden_cmd_rcvd, _x.wrn_memory_access_failure, _x.wrn_int_overflow, _x.wrn_ego_motion_data_missing, _x.wrn_incorrect_mounting_params, _x.wrn_no_obj_comp_due_to_scan_freq,) = _get_struct_2IBH2I37B().unpack(str[start:end])
      self.err_internal_error = bool(self.err_internal_error)
      self.err_motor_1_fault = bool(self.err_motor_1_fault)
      self.err_buffer_error_xmt_incomplete = bool(self.err_buffer_error_xmt_incomplete)
      self.err_buffer_error_overflow = bool(self.err_buffer_error_overflow)
      self.err_apd_over_temperature = bool(self.err_apd_over_temperature)
      self.err_apd_under_temperature = bool(self.err_apd_under_temperature)
      self.err_apd_temperature_sensor_defect = bool(self.err_apd_temperature_sensor_defect)
      self.err_motor_2_fault = bool(self.err_motor_2_fault)
      self.err_motor_3_fault = bool(self.err_motor_3_fault)
      self.err_motor_4_fault = bool(self.err_motor_4_fault)
      self.err_motor_5_fault = bool(self.err_motor_5_fault)
      self.err_int_no_scan_data = bool(self.err_int_no_scan_data)
      self.err_int_communication_error = bool(self.err_int_communication_error)
      self.err_int_incorrect_scan_data = bool(self.err_int_incorrect_scan_data)
      self.err_config_fpga_not_configurable = bool(self.err_config_fpga_not_configurable)
      self.err_config_incorrect_config_data = bool(self.err_config_incorrect_config_data)
      self.err_config_contains_incorrect_params = bool(self.err_config_contains_incorrect_params)
      self.err_timeout_data_processing = bool(self.err_timeout_data_processing)
      self.err_timeout_env_model_computation_reset = bool(self.err_timeout_env_model_computation_reset)
      self.wrn_int_communication_error = bool(self.wrn_int_communication_error)
      self.wrn_low_temperature = bool(self.wrn_low_temperature)
      self.wrn_high_temperature = bool(self.wrn_high_temperature)
      self.wrn_int_motor_1 = bool(self.wrn_int_motor_1)
      self.wrn_sync_error = bool(self.wrn_sync_error)
      self.wrn_laser_1_start_pulse_missing = bool(self.wrn_laser_1_start_pulse_missing)
      self.wrn_laser_2_start_pulse_missing = bool(self.wrn_laser_2_start_pulse_missing)
      self.wrn_can_interface_blocked = bool(self.wrn_can_interface_blocked)
      self.wrn_eth_interface_blocked = bool(self.wrn_eth_interface_blocked)
      self.wrn_incorrect_can_data_rcvd = bool(self.wrn_incorrect_can_data_rcvd)
      self.wrn_int_incorrect_scan_data = bool(self.wrn_int_incorrect_scan_data)
      self.wrn_eth_unkwn_incomplete_data = bool(self.wrn_eth_unkwn_incomplete_data)
      self.wrn_incorrect_or_forbidden_cmd_rcvd = bool(self.wrn_incorrect_or_forbidden_cmd_rcvd)
      self.wrn_memory_access_failure = bool(self.wrn_memory_access_failure)
      self.wrn_int_overflow = bool(self.wrn_int_overflow)
      self.wrn_ego_motion_data_missing = bool(self.wrn_ego_motion_data_missing)
      self.wrn_incorrect_mounting_params = bool(self.wrn_incorrect_mounting_params)
      self.wrn_no_obj_comp_due_to_scan_freq = bool(self.wrn_no_obj_comp_due_to_scan_freq)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_2IBH2I37B().pack(_x.ibeo_header.previous_message_size, _x.ibeo_header.message_size, _x.ibeo_header.device_id, _x.ibeo_header.data_type_id, _x.ibeo_header.stamp.secs, _x.ibeo_header.stamp.nsecs, _x.err_internal_error, _x.err_motor_1_fault, _x.err_buffer_error_xmt_incomplete, _x.err_buffer_error_overflow, _x.err_apd_over_temperature, _x.err_apd_under_temperature, _x.err_apd_temperature_sensor_defect, _x.err_motor_2_fault, _x.err_motor_3_fault, _x.err_motor_4_fault, _x.err_motor_5_fault, _x.err_int_no_scan_data, _x.err_int_communication_error, _x.err_int_incorrect_scan_data, _x.err_config_fpga_not_configurable, _x.err_config_incorrect_config_data, _x.err_config_contains_incorrect_params, _x.err_timeout_data_processing, _x.err_timeout_env_model_computation_reset, _x.wrn_int_communication_error, _x.wrn_low_temperature, _x.wrn_high_temperature, _x.wrn_int_motor_1, _x.wrn_sync_error, _x.wrn_laser_1_start_pulse_missing, _x.wrn_laser_2_start_pulse_missing, _x.wrn_can_interface_blocked, _x.wrn_eth_interface_blocked, _x.wrn_incorrect_can_data_rcvd, _x.wrn_int_incorrect_scan_data, _x.wrn_eth_unkwn_incomplete_data, _x.wrn_incorrect_or_forbidden_cmd_rcvd, _x.wrn_memory_access_failure, _x.wrn_int_overflow, _x.wrn_ego_motion_data_missing, _x.wrn_incorrect_mounting_params, _x.wrn_no_obj_comp_due_to_scan_freq))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.ibeo_header is None:
        self.ibeo_header = ibeo_msgs.msg.IbeoDataHeader()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 56
      (_x.ibeo_header.previous_message_size, _x.ibeo_header.message_size, _x.ibeo_header.device_id, _x.ibeo_header.data_type_id, _x.ibeo_header.stamp.secs, _x.ibeo_header.stamp.nsecs, _x.err_internal_error, _x.err_motor_1_fault, _x.err_buffer_error_xmt_incomplete, _x.err_buffer_error_overflow, _x.err_apd_over_temperature, _x.err_apd_under_temperature, _x.err_apd_temperature_sensor_defect, _x.err_motor_2_fault, _x.err_motor_3_fault, _x.err_motor_4_fault, _x.err_motor_5_fault, _x.err_int_no_scan_data, _x.err_int_communication_error, _x.err_int_incorrect_scan_data, _x.err_config_fpga_not_configurable, _x.err_config_incorrect_config_data, _x.err_config_contains_incorrect_params, _x.err_timeout_data_processing, _x.err_timeout_env_model_computation_reset, _x.wrn_int_communication_error, _x.wrn_low_temperature, _x.wrn_high_temperature, _x.wrn_int_motor_1, _x.wrn_sync_error, _x.wrn_laser_1_start_pulse_missing, _x.wrn_laser_2_start_pulse_missing, _x.wrn_can_interface_blocked, _x.wrn_eth_interface_blocked, _x.wrn_incorrect_can_data_rcvd, _x.wrn_int_incorrect_scan_data, _x.wrn_eth_unkwn_incomplete_data, _x.wrn_incorrect_or_forbidden_cmd_rcvd, _x.wrn_memory_access_failure, _x.wrn_int_overflow, _x.wrn_ego_motion_data_missing, _x.wrn_incorrect_mounting_params, _x.wrn_no_obj_comp_due_to_scan_freq,) = _get_struct_2IBH2I37B().unpack(str[start:end])
      self.err_internal_error = bool(self.err_internal_error)
      self.err_motor_1_fault = bool(self.err_motor_1_fault)
      self.err_buffer_error_xmt_incomplete = bool(self.err_buffer_error_xmt_incomplete)
      self.err_buffer_error_overflow = bool(self.err_buffer_error_overflow)
      self.err_apd_over_temperature = bool(self.err_apd_over_temperature)
      self.err_apd_under_temperature = bool(self.err_apd_under_temperature)
      self.err_apd_temperature_sensor_defect = bool(self.err_apd_temperature_sensor_defect)
      self.err_motor_2_fault = bool(self.err_motor_2_fault)
      self.err_motor_3_fault = bool(self.err_motor_3_fault)
      self.err_motor_4_fault = bool(self.err_motor_4_fault)
      self.err_motor_5_fault = bool(self.err_motor_5_fault)
      self.err_int_no_scan_data = bool(self.err_int_no_scan_data)
      self.err_int_communication_error = bool(self.err_int_communication_error)
      self.err_int_incorrect_scan_data = bool(self.err_int_incorrect_scan_data)
      self.err_config_fpga_not_configurable = bool(self.err_config_fpga_not_configurable)
      self.err_config_incorrect_config_data = bool(self.err_config_incorrect_config_data)
      self.err_config_contains_incorrect_params = bool(self.err_config_contains_incorrect_params)
      self.err_timeout_data_processing = bool(self.err_timeout_data_processing)
      self.err_timeout_env_model_computation_reset = bool(self.err_timeout_env_model_computation_reset)
      self.wrn_int_communication_error = bool(self.wrn_int_communication_error)
      self.wrn_low_temperature = bool(self.wrn_low_temperature)
      self.wrn_high_temperature = bool(self.wrn_high_temperature)
      self.wrn_int_motor_1 = bool(self.wrn_int_motor_1)
      self.wrn_sync_error = bool(self.wrn_sync_error)
      self.wrn_laser_1_start_pulse_missing = bool(self.wrn_laser_1_start_pulse_missing)
      self.wrn_laser_2_start_pulse_missing = bool(self.wrn_laser_2_start_pulse_missing)
      self.wrn_can_interface_blocked = bool(self.wrn_can_interface_blocked)
      self.wrn_eth_interface_blocked = bool(self.wrn_eth_interface_blocked)
      self.wrn_incorrect_can_data_rcvd = bool(self.wrn_incorrect_can_data_rcvd)
      self.wrn_int_incorrect_scan_data = bool(self.wrn_int_incorrect_scan_data)
      self.wrn_eth_unkwn_incomplete_data = bool(self.wrn_eth_unkwn_incomplete_data)
      self.wrn_incorrect_or_forbidden_cmd_rcvd = bool(self.wrn_incorrect_or_forbidden_cmd_rcvd)
      self.wrn_memory_access_failure = bool(self.wrn_memory_access_failure)
      self.wrn_int_overflow = bool(self.wrn_int_overflow)
      self.wrn_ego_motion_data_missing = bool(self.wrn_ego_motion_data_missing)
      self.wrn_incorrect_mounting_params = bool(self.wrn_incorrect_mounting_params)
      self.wrn_no_obj_comp_due_to_scan_freq = bool(self.wrn_no_obj_comp_due_to_scan_freq)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_2IBH2I37B = None
def _get_struct_2IBH2I37B():
    global _struct_2IBH2I37B
    if _struct_2IBH2I37B is None:
        _struct_2IBH2I37B = struct.Struct("<2IBH2I37B")
    return _struct_2IBH2I37B
